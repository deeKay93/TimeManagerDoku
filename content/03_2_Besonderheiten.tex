\subsection{Verzeichnisstruktur}
In \autoref{fig-verzeichnis} sind die ersten zwei Ebenen der Verzeichnisstruktur dargestellt.
Auf die Auflistung automatisch erstellter und nicht veränderter Dateien wird verzichtet.
Der Zweck der Einzelnen Ordner und Dateien wird im Folgenden beschrieben.

\begin{figure}[H]
    \centering
    \begin{forest}
        pic dir tree,
        where level=0{}{% folder icons by default; override using file for file icons
          directory,
        },
      [/
        [App.tsx,file]
        [global.d.ts,file]
        [index.js,file]
        [android]
        [ios]
        [src]
      ]
   \end{forest}
   \begin{forest}
    pic dir tree,
    where level=0{}{% folder icons by default; override using file for file icons
      directory,
    },
    [/src
        [store.ts,file]
        [actions]
        [api]
        [assets]
        [components]
        [container]
        [forms]
        [reducers]
        [sagas]
        [screens]
        [utils]
    ]
\end{forest}
    \caption{Verzeichnisstruktur}
    \label{fig-verzeichnis}
\end{figure}

\paragraph{Oberste Ebene}
\begin{description}
    \item[App.tsx]
    App.tsx ist die Zentrale Datei der Applikation. In ihr wird:
    \begin{itemize}
        \item die Navigation initialisiert,
        \item die Behandlung von Nachrichten eingerichtet,
        \item die Anmeldung des Nutzers sichergestellt,
        \item der Redux-Store mit der App verknüpft.
    \end{itemize}
    \item[global.d.ts]
    Diese Datei wird genutzt um TypeScript-Typen der gesamten Anwendung zur Verfügung zu stellen.
    Hierdurch wird die Arbeit mit komplexeren Datentypen erheblich erleichtert.
    \item[index.js]
    In der Datei wird die Anwendung \enquote{registiert}. Hierdurch werden die React-Native-Componenten mit der nativen Applikation verknüpft.
    Diese automatisch generierte Funktion wird ergänzt durch einen sogenannten \emph{Polyfill}, der genutzt wird,
    um fehlende JavaScript-Funktionalitäten zu ermöglichen. \cite{undefine14:online}
    \item[android]
    Dieser Ordner enthält den Quellcode für die native Android App.
    Wird nativer Code - beispielsweise von React-Native-Firebase - genutzt,
    so muss er hier hinzugefügt werden.
    \item[ios]
    Dieser Ordner ist das Pendant zu vorigem Ordner.
    Da sich dieser Programmentwurf auf Android-Geräte beschränkt,
    bleibt er von manuellen Eingriffen unberührt.
    \item[src]
    In diesem Ordner befindet sich der größte Teil des relevanten Quellcodes.
    Dessen Inhalt wird im folgenden näher betrachtet.
\end{description}

\paragraph{src-Ordner}
Die Aufteilung des \emph{src}-Ordners orientiert sich an dem verbreiteten \emph{Rails-style} \cite{CodeStru4:online}.
Dies bedeutet, dass für jede \enquote{Art} von Bausteinen der Applikation ein eigener Ordner angelegt wird.
Somit ergibt sich folgende Struktur:

\begin{description}
    \item[store.ts]
    In der einzigen Datei direkt im src-Ordner werden die gesamten Reducer zum Redux-Store zusammengefasst und mit
    Redux-Saga verknüpft.
    \item[actions]

    \item[api]
    \item[assets]
    \item[components]
    \item[container]
    \item[forms]
    \item[reducers]
    \item[sagas]
    \item[screens]
    \item[utils]
\end{description}


% \item Codestruktur UI
% \begin{itemize}
%     \item screens
%     \item components
%     \item forms
%     \item container
% \end{itemize}
% \item Codestruktur Redux
% \begin{itemize}
%     \item reducer
%     \item store
%     \item action
% \end{itemize}
% \item Codestruktur Redux-Saga und Firebase
% \begin{itemize}
%     \item sagas
%     \item api
% \end{itemize}


\subsection{Besonderheiten (Daniel)}
\subsubsection{Login}
Sicherstellung über Login-Decider
Verweis auf Firebase login

\subsubsection{Firebase}
\paragraph{Login}
Erklärung UID

\paragraph{Datenspeicherung}
Wie bereits beschrieben werden die Daten im \textit{Cloud Firestore} gespeichert.
Auf oberster Ebene werden Sammlungen angelegt.
Eine solche Sammlung enthält beliebig viele Dokumente.
Ein Dokument wiederum kann Daten in einem JSON-ähnlichen Format und weitere Sammlungen enthalten.
So lässt sich die gesamte Daten aus wechselnden Sammlungen und Dokumenten strukturieren.

Die Struktur für diesen Programmentwurf ist in \autoref{app-datenbank} dargestellt und wird im folgenden beschrieben:

Auf oberster Ebene werden unter der Sammlung \texttt{users} alle Benutzer eingeordnet.
Für jeden der Benutzer wird ein Dokument mit dessen Firebase-UID angelegt.
Diese Dokument besitzt ein Feld für den Namen des Nutzers,
sowie die Sammlungen \texttt{categories} und \texttt{holidays}.

\texttt{categories} enthält für jede Kategorie ein Dokument mit automatisch generierter ID angelegt.
In diesem Dokument befinden sich neben dem Namen alle für die Zeiterfassung relevanten Daten.
Auf diese wird im Verlauf dieser Arbeit genauer eingegangen.
Außerdem enthält eine Kategorie-Dokument die Sammlung \texttt{times}.
Diese wiederum enthält für jede getätigte Zeiterfassung ein Dokument mit Start- und Stoppzeit sowie den gesamten Minuten.

Die Sammlung \texttt{holidays} enthält alle vom Nutzer gepflegten freie Tage mit den notwendigen Informationen.

Um sicherzustellen, dass nur angemeldete Nutzer Zugriff auf ihre Daten haben,
können sogenannte \textit{Regeln} angelegt werden.
Die Regel für diesen Programmentwurf ist in \autoref{lst:firestore-rule} dargestellt.
Über die ersten beiden Zeilen wird die Datenbank an sich addressiert.
In durch die Zeilen 3 und 4 wird geprüft, ob die Nutzer-UID mit dem Titel des Dokuments übereinstimmt.
ist dies der Fall, so werden Lese- und Schreibrechte gestattet.
In Zeile 5 wird durch \lstinline[language=firestoreRule]{**} angegeben,
dass die darauffolgende Regel für alle darunterliegenden Dokumente gilt.
In diesem Fall wird die Regel aus Zeile 4 wiederholt.

\lstinputlisting[
    caption=Regeln für Firestore,
    label=lst:firestore-rule,
    language=firestoreRule,
    float=ht
]{firestoreRule.txt}


Insgeamt besagt die Regel,
dass ein angemeldeter Benutzer auf das zu seinem Benutzer zugehörige Dokument,
sowie alle darunterliegenden Dokumente volle Schreib- und Leseberechtigungen erhält.
Für eine produktive Anwendung könnten diese Regeln noch ergänzt werden.
Beispielsweise sind strengere Regeln zur Einhaltung der Datanbankstruktur oder Validierungen der eingegebenen Daten denkbar.
Für die Entwicklung eines Prototyps sind solch strenge Regeln allerdings eher hinderlich.

\subsubsection{Freie Tage (Lea)}

\subsubsection{Ablauf der Zeiterfassung}
Ablaufdiagramm mit Beschreibung

\subsubsection{Zeitberechnungen}
Berechnungen mit Moment

\subsubsection{Darstellung von Zeiten}
Die Darstellung der Zeiten stellt eine designerische und eine technische Herausforderung.

\paragraph{Design}
Die Zeiten sollte so dargestellt werden,
dass der Nutzer sie eindeutig verstehen kann und alle notwendigen Informationen erhält.
Trennt mann beispielsweise die Zeiteinheiten immer mit einem Doppelpunkt und zeigt nicht immer die Sekunden an,
so kann es zu Verwirrungen zwischen \enquote{12:23} als \enquote{12 Stunden 23 Minuten}
und \enquote{12:23} als \enquote{12 Minuten 23 Sekunden} kommen.

Um diese Ziele zu erreichen erfolgt die Darstellung nach den in \autoref{fig:darstellung-zeiten} beschriebenen Regeln.

\begin{figure}[ht!]
    \centering
    \resizebox{\textwidth}{!}{
        \input{assets/img/diagramme/ZeitDarstellung.latex}
    }
    \caption{Darstellung von Zeiten}
    \label{fig:darstellung-zeiten}
\end{figure}


% \begin{algorithm}
%     \caption{Darstellung von Zeiten}
%     \label{alg:darstellung-zeiten}
%     \uIf{Zeit $\geq$ 10 Tage}{
%         Darstellung: \enquote{$DD$d} \tcc*[r]{13d}
%     }
%     \uElseIf{Zeit $>$ 1.5 Tage}{
%         Darstellung: \enquote{$DD$d $HH$h} \tcc*[r]{04d 12h}
%     }
%     \Else{
%         \uIf{Doppelpunkt als Trenner}{
%             \If{Zeit $\geq$ 1 Stunde}{
%                 Darstellung: \enquote{$HH$:$MM$:$SS$} \tcc*[r]{02:12:24}
%             }
%             \Else{
%                 Darstellung: \enquote{$MM$:$SS$} \tcc*[r]{12:24}
%             }
%         }
%         \Else{
%             \If{Zeit $\geq$ 10 Stunden}{
%                 Darstellung: \enquote{$HH$h $MM$m} \tcc*[r]{12h 13m}
%             }
%             \uElseIf{Zeit $\geq$ 1 Stunde}{
%                 Darstellung: \enquote{$HH$h $MM$m $SS$s} \tcc*[r]{09h 24m 42s}
%             }
%             \Else{
%                 Darstellung: \enquote{$MM$m $SS$s} \tcc*[r]{13m 37s}
%             }
%         }
%     }

% \end{algorithm}

Hierdurch wird erreicht, dass bei Darstellung mit Doppelpunkt immer die Sekunden angezeit werden.
Bei Zeiten über anderhalbt Tagen wird die Zeit überhaupt nicht mit Doppelpunkten dargestellt.
In der alternativen Darstellung mit Buchstaben wird durch den Buchstaben die Zeiteinheit eindeutig zugeordnet.
Daher kann hier bei entsprechend hohen Werten auf die Darstellung der kleineren Einheiten verzichtet werden.

\paragraph{Technisch}
Läuft gerade eine Zeitmessung so soll der aktuelle Stand auch dem Nutzer präsentiert werden.
Hierbei soll sich der Wert logischerweise regelmäßig aktualisieren,
was technisch bedeutet, dass die React-Komponente neu gezeichnet werden muss.
Solch eine \enquote{Neu-Zeichnung} wird in React durch eine Änderung des States der Komponente erreicht.
Durch Redux hat allerdings eigentlich keines der Komponenten einen State.
Statdessen gibt es einen State für die gesamte Anwendung.

In \cite{Timersin85:online} werden drei Alternativen vorgestellt um dieses Problem zu lösen:
\begin{enumerate}
    \item Die Komponente erhält einen internen State,
    \item Es werden Redux-Actions für die Komponente angelegt und bei Bedarf gestartet oder gestoppt.
    \item Ein Globaler Timer läuft im Hintergrund und die Komponente wird bei diesem Timer registiert.
\end{enumerate}

Da es sich in diesem Beispiel um eine reine Darstellung handelt,
wird Variante 1 implementiert, indem das Beispiel aus \cite{Timersin85:online} auf den Anwendungsfall angepasst wird.
\autoref{lst:timer} zeigt den Quellcode der Klasse \texttt{Timer} mit folgenden Aspekten:
\begin{description}
    \item[Props] Dies sind die Eigenschaften, welche vom Elternelement Übergeben werden.
    \texttt{startTime} ist die Zeit, ab welcher der Timer läuft.
    Wird auch die optionale \texttt{baseTime} gesetzt, so werden diese beiden verrechnet.
    Zudem können an die Komponente alle Props übergeben werden, welche auch an eine Textkomponente üebrgeben werden.
    Diese werden an die interne Textkomponente weitergereicht.
    Die Props sind nicht veränderlich.
    \item[State] Der State ist der veränderliche Teil der Komponente.
    Er beinhaltet die \texttt{timerId} um den Timer wieder stoppen zu können,
    sowie den darzustellenden Text.
    \item[Ablauf]
    Um den Text zu aktualisieren wird durchläuft die Komponente folgende Phasen:
    \begin{enumerate}
        \item Beim Erzeugen des Timers wird State initialisiert.
        \item Sobald die Komponente Teil der Darzustellenden Komponenten wurde (\texttt{componentDidMount}),
        wird ein Intervall gestartet, welcher sekündlich die \texttt{tick}-Methode aufruft.
        \item In der \texttt{tick} wird der neu darzustellende Text ermittelt und der State aktualisiert.
        \item Wird der Timer entfernt, so wird das Intervall gestoppt.
    \end{enumerate}
\end{description}

\lstinputlisting[
    caption={Timer.tsx},
    label=lst:timer,
    language=TypeScript,
    firstnumber=5,
    firstline=5
]{Timer.tsx}


\subsubsection{Dialoge, DatePicker}
Losgelöst von Redux-State

\subsubsection{Benachrichtigungen}
Zur Darstellung der lokalen Benachrichtigungen wird das \emph{React Native Firebase's Notifications}-Modul genutzt.
Es bietet einfache Schnittstellen um Benachrichtigungen zu erzeugen,
sie direkt anzuzeigen oder für einen bestimmten Zeitpunkt zu planen.
Durch das Singleton \texttt{NavigationService} werden diese Schnittstellen weiter vereinfacht und auf den Anwendungsfall angepasst.
Die Klasse hat hierbei zwei Aufgaben: Das Senden bzw. Planen von Benachrichtigungen und die Behandlung eingehender Benachrichtigungen:

\paragraph{Senden und Planen von Benachrichtigungen}
Hierfür werden verschiedene Funktionen zur Verfügung gestellt:
\begin{description}
    \item[buildNotification] erzeugt eine Benachrichtigung mit ID, Titel, Inhalt und Kanal
        \footnote{Ein Kanal wird von Android genutzt um Benachrichtigungen zu klassifizieren. In dieser Anwenung wird lediglich ein Default-Kanal verwendet.}.
    \item[scheduleNotification] erhält zusätzlich zu den obigen Informationen noch einen Zeitpunkt an welchem die Benachrichtigung erscheinen soll.
    \item[cancelNotificationIfExists] wird genutzt, um eine bereits geplante Benachrichtigung abzubrechen. Hierfür erhält es die ID der Benachrichtigung.
\end{description}

\paragraph{Behandlung eingehender Benachrichtigungen}
Bei der Behandlung eingehender Benachrichtigungen gilt es,
verschiedene Situationen zu Betrachten und jeweils entsprechend zu reagieren \cite{Introduc87:online}.
\begin{description}
    \item[App wird durch eine Benachrichtigung gestartet]
    Läuft die App nicht, so werden bereits geplante Benachrichtigungen durch das Betriebssystem angezeigt.
    Klickt der Nutzer auf diese, so wird dadurch die App gestartet.
    In der App wird dafür gesorgt, dass die Benachrichtigung entfernt wird.
    
    \item[App wird durch eine Benachrichtigung geöffnet]
    Befindet sich die App im Hintergrund,
    dann wird eine Benachrichtigung ebenfalls durch das Betriebssystem angezeigt.
    Auch hier wird die Benachrichtigung durch die App entfernt.

    \item[Eine Benachrichtigung wird bei aktiver App empfangen]
    Ist die App aktiv, so wird eine Benachrichtigung zwar empfangen,
    aber nicht automatisch durch das Betriebssystem angezeigt.
    In diesem Fall geschieht dies durch Programmcode.
    
    \item[Benachrichtigung wird bei aktiver App angezeigt]
    In diesem Fall wird bei aktiver Applikation eine Benachrichtigung angezeigt.
    Bei lokalen Benachrichtigungen ist dies nur der Fall,
    wenn die Applikation \enquote{bewusst} eine Benachrichtigung anzeigt.

\end{description}


Berechnungen der Zielzeit

Verschiedene Listener in App.tsx

\todo[inline]{Ergebnis}